// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateDisplay {
  count: Int!
}

type AggregateProgress {
  count: Int!
}

type AggregateSeason {
  count: Int!
}

type AggregateSerie {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVideo {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Display {
  id: ID!
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

type DisplayConnection {
  pageInfo: PageInfo!
  edges: [DisplayEdge]!
  aggregate: AggregateDisplay!
}

input DisplayCreateInput {
  id: ID
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayCreateManyInput {
  create: [DisplayCreateInput!]
  connect: [DisplayWhereUniqueInput!]
}

input DisplayCreateOneInput {
  create: DisplayCreateInput
  connect: DisplayWhereUniqueInput
}

type DisplayEdge {
  node: Display!
  cursor: String!
}

enum DisplayOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  trailer_ASC
  trailer_DESC
  big_ASC
  big_DESC
  medium_ASC
  medium_DESC
  small_ASC
  small_DESC
  likeable_ASC
  likeable_DESC
}

type DisplayPreviousValues {
  id: ID!
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: MediaType
  type_not: MediaType
  type_in: [MediaType!]
  type_not_in: [MediaType!]
  trailer: String
  trailer_not: String
  trailer_in: [String!]
  trailer_not_in: [String!]
  trailer_lt: String
  trailer_lte: String
  trailer_gt: String
  trailer_gte: String
  trailer_contains: String
  trailer_not_contains: String
  trailer_starts_with: String
  trailer_not_starts_with: String
  trailer_ends_with: String
  trailer_not_ends_with: String
  big: String
  big_not: String
  big_in: [String!]
  big_not_in: [String!]
  big_lt: String
  big_lte: String
  big_gt: String
  big_gte: String
  big_contains: String
  big_not_contains: String
  big_starts_with: String
  big_not_starts_with: String
  big_ends_with: String
  big_not_ends_with: String
  medium: String
  medium_not: String
  medium_in: [String!]
  medium_not_in: [String!]
  medium_lt: String
  medium_lte: String
  medium_gt: String
  medium_gte: String
  medium_contains: String
  medium_not_contains: String
  medium_starts_with: String
  medium_not_starts_with: String
  medium_ends_with: String
  medium_not_ends_with: String
  small: String
  small_not: String
  small_in: [String!]
  small_not_in: [String!]
  small_lt: String
  small_lte: String
  small_gt: String
  small_gte: String
  small_contains: String
  small_not_contains: String
  small_starts_with: String
  small_not_starts_with: String
  small_ends_with: String
  small_not_ends_with: String
  likeable: Likeable
  likeable_not: Likeable
  likeable_in: [Likeable!]
  likeable_not_in: [Likeable!]
  AND: [DisplayScalarWhereInput!]
  OR: [DisplayScalarWhereInput!]
  NOT: [DisplayScalarWhereInput!]
}

type DisplaySubscriptionPayload {
  mutation: MutationType!
  node: Display
  updatedFields: [String!]
  previousValues: DisplayPreviousValues
}

input DisplaySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DisplayWhereInput
  AND: [DisplaySubscriptionWhereInput!]
  OR: [DisplaySubscriptionWhereInput!]
  NOT: [DisplaySubscriptionWhereInput!]
}

input DisplayUpdateDataInput {
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayUpdateInput {
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayUpdateManyDataInput {
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayUpdateManyInput {
  create: [DisplayCreateInput!]
  update: [DisplayUpdateWithWhereUniqueNestedInput!]
  upsert: [DisplayUpsertWithWhereUniqueNestedInput!]
  delete: [DisplayWhereUniqueInput!]
  connect: [DisplayWhereUniqueInput!]
  set: [DisplayWhereUniqueInput!]
  disconnect: [DisplayWhereUniqueInput!]
  deleteMany: [DisplayScalarWhereInput!]
  updateMany: [DisplayUpdateManyWithWhereNestedInput!]
}

input DisplayUpdateManyMutationInput {
  name: String
  type: MediaType
  trailer: String
  big: String
  medium: String
  small: String
  likeable: Likeable
}

input DisplayUpdateManyWithWhereNestedInput {
  where: DisplayScalarWhereInput!
  data: DisplayUpdateManyDataInput!
}

input DisplayUpdateOneInput {
  create: DisplayCreateInput
  update: DisplayUpdateDataInput
  upsert: DisplayUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DisplayWhereUniqueInput
}

input DisplayUpdateOneRequiredInput {
  create: DisplayCreateInput
  update: DisplayUpdateDataInput
  upsert: DisplayUpsertNestedInput
  connect: DisplayWhereUniqueInput
}

input DisplayUpdateWithWhereUniqueNestedInput {
  where: DisplayWhereUniqueInput!
  data: DisplayUpdateDataInput!
}

input DisplayUpsertNestedInput {
  update: DisplayUpdateDataInput!
  create: DisplayCreateInput!
}

input DisplayUpsertWithWhereUniqueNestedInput {
  where: DisplayWhereUniqueInput!
  update: DisplayUpdateDataInput!
  create: DisplayCreateInput!
}

input DisplayWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: MediaType
  type_not: MediaType
  type_in: [MediaType!]
  type_not_in: [MediaType!]
  trailer: String
  trailer_not: String
  trailer_in: [String!]
  trailer_not_in: [String!]
  trailer_lt: String
  trailer_lte: String
  trailer_gt: String
  trailer_gte: String
  trailer_contains: String
  trailer_not_contains: String
  trailer_starts_with: String
  trailer_not_starts_with: String
  trailer_ends_with: String
  trailer_not_ends_with: String
  big: String
  big_not: String
  big_in: [String!]
  big_not_in: [String!]
  big_lt: String
  big_lte: String
  big_gt: String
  big_gte: String
  big_contains: String
  big_not_contains: String
  big_starts_with: String
  big_not_starts_with: String
  big_ends_with: String
  big_not_ends_with: String
  medium: String
  medium_not: String
  medium_in: [String!]
  medium_not_in: [String!]
  medium_lt: String
  medium_lte: String
  medium_gt: String
  medium_gte: String
  medium_contains: String
  medium_not_contains: String
  medium_starts_with: String
  medium_not_starts_with: String
  medium_ends_with: String
  medium_not_ends_with: String
  small: String
  small_not: String
  small_in: [String!]
  small_not_in: [String!]
  small_lt: String
  small_lte: String
  small_gt: String
  small_gte: String
  small_contains: String
  small_not_contains: String
  small_starts_with: String
  small_not_starts_with: String
  small_ends_with: String
  small_not_ends_with: String
  likeable: Likeable
  likeable_not: Likeable
  likeable_in: [Likeable!]
  likeable_not_in: [Likeable!]
  AND: [DisplayWhereInput!]
  OR: [DisplayWhereInput!]
  NOT: [DisplayWhereInput!]
}

input DisplayWhereUniqueInput {
  id: ID
}

enum Likeable {
  LIKEABLE
  NOT_LIKEABLE
}

scalar Long

enum MediaType {
  SERIE
  MOVIE
  MANGA
  ANIME
}

type Mutation {
  createDisplay(data: DisplayCreateInput!): Display!
  updateDisplay(data: DisplayUpdateInput!, where: DisplayWhereUniqueInput!): Display
  updateManyDisplays(data: DisplayUpdateManyMutationInput!, where: DisplayWhereInput): BatchPayload!
  upsertDisplay(where: DisplayWhereUniqueInput!, create: DisplayCreateInput!, update: DisplayUpdateInput!): Display!
  deleteDisplay(where: DisplayWhereUniqueInput!): Display
  deleteManyDisplays(where: DisplayWhereInput): BatchPayload!
  createProgress(data: ProgressCreateInput!): Progress!
  updateProgress(data: ProgressUpdateInput!, where: ProgressWhereUniqueInput!): Progress
  updateManyProgresses(data: ProgressUpdateManyMutationInput!, where: ProgressWhereInput): BatchPayload!
  upsertProgress(where: ProgressWhereUniqueInput!, create: ProgressCreateInput!, update: ProgressUpdateInput!): Progress!
  deleteProgress(where: ProgressWhereUniqueInput!): Progress
  deleteManyProgresses(where: ProgressWhereInput): BatchPayload!
  createSeason(data: SeasonCreateInput!): Season!
  updateSeason(data: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season
  updateManySeasons(data: SeasonUpdateManyMutationInput!, where: SeasonWhereInput): BatchPayload!
  upsertSeason(where: SeasonWhereUniqueInput!, create: SeasonCreateInput!, update: SeasonUpdateInput!): Season!
  deleteSeason(where: SeasonWhereUniqueInput!): Season
  deleteManySeasons(where: SeasonWhereInput): BatchPayload!
  createSerie(data: SerieCreateInput!): Serie!
  updateSerie(data: SerieUpdateInput!, where: SerieWhereUniqueInput!): Serie
  updateManySeries(data: SerieUpdateManyMutationInput!, where: SerieWhereInput): BatchPayload!
  upsertSerie(where: SerieWhereUniqueInput!, create: SerieCreateInput!, update: SerieUpdateInput!): Serie!
  deleteSerie(where: SerieWhereUniqueInput!): Serie
  deleteManySeries(where: SerieWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVideo(data: VideoCreateInput!): Video!
  updateVideo(data: VideoUpdateInput!, where: VideoWhereUniqueInput!): Video
  updateManyVideos(data: VideoUpdateManyMutationInput!, where: VideoWhereInput): BatchPayload!
  upsertVideo(where: VideoWhereUniqueInput!, create: VideoCreateInput!, update: VideoUpdateInput!): Video!
  deleteVideo(where: VideoWhereUniqueInput!): Video
  deleteManyVideos(where: VideoWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Progress {
  id: ID!
  avancement: Float!
  video: Video!
  user: User!
}

type ProgressConnection {
  pageInfo: PageInfo!
  edges: [ProgressEdge]!
  aggregate: AggregateProgress!
}

input ProgressCreateInput {
  id: ID
  avancement: Float!
  video: VideoCreateOneInput!
  user: UserCreateOneWithoutProgressesInput!
}

input ProgressCreateManyWithoutUserInput {
  create: [ProgressCreateWithoutUserInput!]
  connect: [ProgressWhereUniqueInput!]
}

input ProgressCreateWithoutUserInput {
  id: ID
  avancement: Float!
  video: VideoCreateOneInput!
}

type ProgressEdge {
  node: Progress!
  cursor: String!
}

enum ProgressOrderByInput {
  id_ASC
  id_DESC
  avancement_ASC
  avancement_DESC
}

type ProgressPreviousValues {
  id: ID!
  avancement: Float!
}

input ProgressScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  avancement: Float
  avancement_not: Float
  avancement_in: [Float!]
  avancement_not_in: [Float!]
  avancement_lt: Float
  avancement_lte: Float
  avancement_gt: Float
  avancement_gte: Float
  AND: [ProgressScalarWhereInput!]
  OR: [ProgressScalarWhereInput!]
  NOT: [ProgressScalarWhereInput!]
}

type ProgressSubscriptionPayload {
  mutation: MutationType!
  node: Progress
  updatedFields: [String!]
  previousValues: ProgressPreviousValues
}

input ProgressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProgressWhereInput
  AND: [ProgressSubscriptionWhereInput!]
  OR: [ProgressSubscriptionWhereInput!]
  NOT: [ProgressSubscriptionWhereInput!]
}

input ProgressUpdateInput {
  avancement: Float
  video: VideoUpdateOneRequiredInput
  user: UserUpdateOneRequiredWithoutProgressesInput
}

input ProgressUpdateManyDataInput {
  avancement: Float
}

input ProgressUpdateManyMutationInput {
  avancement: Float
}

input ProgressUpdateManyWithoutUserInput {
  create: [ProgressCreateWithoutUserInput!]
  delete: [ProgressWhereUniqueInput!]
  connect: [ProgressWhereUniqueInput!]
  set: [ProgressWhereUniqueInput!]
  disconnect: [ProgressWhereUniqueInput!]
  update: [ProgressUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ProgressUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ProgressScalarWhereInput!]
  updateMany: [ProgressUpdateManyWithWhereNestedInput!]
}

input ProgressUpdateManyWithWhereNestedInput {
  where: ProgressScalarWhereInput!
  data: ProgressUpdateManyDataInput!
}

input ProgressUpdateWithoutUserDataInput {
  avancement: Float
  video: VideoUpdateOneRequiredInput
}

input ProgressUpdateWithWhereUniqueWithoutUserInput {
  where: ProgressWhereUniqueInput!
  data: ProgressUpdateWithoutUserDataInput!
}

input ProgressUpsertWithWhereUniqueWithoutUserInput {
  where: ProgressWhereUniqueInput!
  update: ProgressUpdateWithoutUserDataInput!
  create: ProgressCreateWithoutUserInput!
}

input ProgressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  avancement: Float
  avancement_not: Float
  avancement_in: [Float!]
  avancement_not_in: [Float!]
  avancement_lt: Float
  avancement_lte: Float
  avancement_gt: Float
  avancement_gte: Float
  video: VideoWhereInput
  user: UserWhereInput
  AND: [ProgressWhereInput!]
  OR: [ProgressWhereInput!]
  NOT: [ProgressWhereInput!]
}

input ProgressWhereUniqueInput {
  id: ID
}

type Query {
  display(where: DisplayWhereUniqueInput!): Display
  displays(where: DisplayWhereInput, orderBy: DisplayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Display]!
  displaysConnection(where: DisplayWhereInput, orderBy: DisplayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DisplayConnection!
  progress(where: ProgressWhereUniqueInput!): Progress
  progresses(where: ProgressWhereInput, orderBy: ProgressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Progress]!
  progressesConnection(where: ProgressWhereInput, orderBy: ProgressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProgressConnection!
  season(where: SeasonWhereUniqueInput!): Season
  seasons(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Season]!
  seasonsConnection(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeasonConnection!
  serie(where: SerieWhereUniqueInput!): Serie
  series(where: SerieWhereInput, orderBy: SerieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Serie]!
  seriesConnection(where: SerieWhereInput, orderBy: SerieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SerieConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  video(where: VideoWhereUniqueInput!): Video
  videos(where: VideoWhereInput, orderBy: VideoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Video]!
  videosConnection(where: VideoWhereInput, orderBy: VideoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VideoConnection!
  node(id: ID!): Node
}

type Season {
  id: ID!
  name: String
  episodes(where: VideoWhereInput, orderBy: VideoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Video!]
}

type SeasonConnection {
  pageInfo: PageInfo!
  edges: [SeasonEdge]!
  aggregate: AggregateSeason!
}

input SeasonCreateInput {
  id: ID
  name: String
  episodes: VideoCreateManyWithoutSeasonInput
}

input SeasonCreateManyInput {
  create: [SeasonCreateInput!]
  connect: [SeasonWhereUniqueInput!]
}

input SeasonCreateOneWithoutEpisodesInput {
  create: SeasonCreateWithoutEpisodesInput
  connect: SeasonWhereUniqueInput
}

input SeasonCreateWithoutEpisodesInput {
  id: ID
  name: String
}

type SeasonEdge {
  node: Season!
  cursor: String!
}

enum SeasonOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type SeasonPreviousValues {
  id: ID!
  name: String
}

input SeasonScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [SeasonScalarWhereInput!]
  OR: [SeasonScalarWhereInput!]
  NOT: [SeasonScalarWhereInput!]
}

type SeasonSubscriptionPayload {
  mutation: MutationType!
  node: Season
  updatedFields: [String!]
  previousValues: SeasonPreviousValues
}

input SeasonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeasonWhereInput
  AND: [SeasonSubscriptionWhereInput!]
  OR: [SeasonSubscriptionWhereInput!]
  NOT: [SeasonSubscriptionWhereInput!]
}

input SeasonUpdateDataInput {
  name: String
  episodes: VideoUpdateManyWithoutSeasonInput
}

input SeasonUpdateInput {
  name: String
  episodes: VideoUpdateManyWithoutSeasonInput
}

input SeasonUpdateManyDataInput {
  name: String
}

input SeasonUpdateManyInput {
  create: [SeasonCreateInput!]
  update: [SeasonUpdateWithWhereUniqueNestedInput!]
  upsert: [SeasonUpsertWithWhereUniqueNestedInput!]
  delete: [SeasonWhereUniqueInput!]
  connect: [SeasonWhereUniqueInput!]
  set: [SeasonWhereUniqueInput!]
  disconnect: [SeasonWhereUniqueInput!]
  deleteMany: [SeasonScalarWhereInput!]
  updateMany: [SeasonUpdateManyWithWhereNestedInput!]
}

input SeasonUpdateManyMutationInput {
  name: String
}

input SeasonUpdateManyWithWhereNestedInput {
  where: SeasonScalarWhereInput!
  data: SeasonUpdateManyDataInput!
}

input SeasonUpdateOneWithoutEpisodesInput {
  create: SeasonCreateWithoutEpisodesInput
  update: SeasonUpdateWithoutEpisodesDataInput
  upsert: SeasonUpsertWithoutEpisodesInput
  delete: Boolean
  disconnect: Boolean
  connect: SeasonWhereUniqueInput
}

input SeasonUpdateWithoutEpisodesDataInput {
  name: String
}

input SeasonUpdateWithWhereUniqueNestedInput {
  where: SeasonWhereUniqueInput!
  data: SeasonUpdateDataInput!
}

input SeasonUpsertWithoutEpisodesInput {
  update: SeasonUpdateWithoutEpisodesDataInput!
  create: SeasonCreateWithoutEpisodesInput!
}

input SeasonUpsertWithWhereUniqueNestedInput {
  where: SeasonWhereUniqueInput!
  update: SeasonUpdateDataInput!
  create: SeasonCreateInput!
}

input SeasonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  episodes_every: VideoWhereInput
  episodes_some: VideoWhereInput
  episodes_none: VideoWhereInput
  AND: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
}

input SeasonWhereUniqueInput {
  id: ID
}

type Serie {
  id: ID!
  name: String!
  display: Display
  seasons(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Season!]
}

type SerieConnection {
  pageInfo: PageInfo!
  edges: [SerieEdge]!
  aggregate: AggregateSerie!
}

input SerieCreateInput {
  id: ID
  name: String!
  display: DisplayCreateOneInput
  seasons: SeasonCreateManyInput
}

type SerieEdge {
  node: Serie!
  cursor: String!
}

enum SerieOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type SeriePreviousValues {
  id: ID!
  name: String!
}

type SerieSubscriptionPayload {
  mutation: MutationType!
  node: Serie
  updatedFields: [String!]
  previousValues: SeriePreviousValues
}

input SerieSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SerieWhereInput
  AND: [SerieSubscriptionWhereInput!]
  OR: [SerieSubscriptionWhereInput!]
  NOT: [SerieSubscriptionWhereInput!]
}

input SerieUpdateInput {
  name: String
  display: DisplayUpdateOneInput
  seasons: SeasonUpdateManyInput
}

input SerieUpdateManyMutationInput {
  name: String
}

input SerieWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  display: DisplayWhereInput
  seasons_every: SeasonWhereInput
  seasons_some: SeasonWhereInput
  seasons_none: SeasonWhereInput
  AND: [SerieWhereInput!]
  OR: [SerieWhereInput!]
  NOT: [SerieWhereInput!]
}

input SerieWhereUniqueInput {
  id: ID
}

enum Sexe {
  MALE
  FEMALE
  OTHER
}

type Subscription {
  display(where: DisplaySubscriptionWhereInput): DisplaySubscriptionPayload
  progress(where: ProgressSubscriptionWhereInput): ProgressSubscriptionPayload
  season(where: SeasonSubscriptionWhereInput): SeasonSubscriptionPayload
  serie(where: SerieSubscriptionWhereInput): SerieSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  video(where: VideoSubscriptionWhereInput): VideoSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  username: String!
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences(where: DisplayWhereInput, orderBy: DisplayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Display!]
  description: String
  sexe: Sexe
  progresses(where: ProgressWhereInput, orderBy: ProgressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Progress!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences: DisplayCreateManyInput
  description: String
  sexe: Sexe
  progresses: ProgressCreateManyWithoutUserInput
}

input UserCreateOneWithoutProgressesInput {
  create: UserCreateWithoutProgressesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutProgressesInput {
  id: ID
  username: String!
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences: DisplayCreateManyInput
  description: String
  sexe: Sexe
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  username_ASC
  username_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  firstname_ASC
  firstname_DESC
  lastname_ASC
  lastname_DESC
  birthday_ASC
  birthday_DESC
  description_ASC
  description_DESC
  sexe_ASC
  sexe_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  username: String!
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  description: String
  sexe: Sexe
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  username: String
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences: DisplayUpdateManyInput
  description: String
  sexe: Sexe
  progresses: ProgressUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  username: String
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  description: String
  sexe: Sexe
}

input UserUpdateOneRequiredWithoutProgressesInput {
  create: UserCreateWithoutProgressesInput
  update: UserUpdateWithoutProgressesDataInput
  upsert: UserUpsertWithoutProgressesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutProgressesDataInput {
  username: String
  email: String
  password: String
  firstname: String
  lastname: String
  birthday: DateTime
  preferences: DisplayUpdateManyInput
  description: String
  sexe: Sexe
}

input UserUpsertWithoutProgressesInput {
  update: UserUpdateWithoutProgressesDataInput!
  create: UserCreateWithoutProgressesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  firstname: String
  firstname_not: String
  firstname_in: [String!]
  firstname_not_in: [String!]
  firstname_lt: String
  firstname_lte: String
  firstname_gt: String
  firstname_gte: String
  firstname_contains: String
  firstname_not_contains: String
  firstname_starts_with: String
  firstname_not_starts_with: String
  firstname_ends_with: String
  firstname_not_ends_with: String
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  birthday: DateTime
  birthday_not: DateTime
  birthday_in: [DateTime!]
  birthday_not_in: [DateTime!]
  birthday_lt: DateTime
  birthday_lte: DateTime
  birthday_gt: DateTime
  birthday_gte: DateTime
  preferences_every: DisplayWhereInput
  preferences_some: DisplayWhereInput
  preferences_none: DisplayWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  sexe: Sexe
  sexe_not: Sexe
  sexe_in: [Sexe!]
  sexe_not_in: [Sexe!]
  progresses_every: ProgressWhereInput
  progresses_some: ProgressWhereInput
  progresses_none: ProgressWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
  email: String
}

type Video {
  id: ID!
  name: String!
  url: String!
  display: Display!
  season: Season
}

type VideoConnection {
  pageInfo: PageInfo!
  edges: [VideoEdge]!
  aggregate: AggregateVideo!
}

input VideoCreateInput {
  id: ID
  name: String!
  url: String!
  display: DisplayCreateOneInput!
  season: SeasonCreateOneWithoutEpisodesInput
}

input VideoCreateManyWithoutSeasonInput {
  create: [VideoCreateWithoutSeasonInput!]
  connect: [VideoWhereUniqueInput!]
}

input VideoCreateOneInput {
  create: VideoCreateInput
  connect: VideoWhereUniqueInput
}

input VideoCreateWithoutSeasonInput {
  id: ID
  name: String!
  url: String!
  display: DisplayCreateOneInput!
}

type VideoEdge {
  node: Video!
  cursor: String!
}

enum VideoOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  url_ASC
  url_DESC
}

type VideoPreviousValues {
  id: ID!
  name: String!
  url: String!
}

input VideoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [VideoScalarWhereInput!]
  OR: [VideoScalarWhereInput!]
  NOT: [VideoScalarWhereInput!]
}

type VideoSubscriptionPayload {
  mutation: MutationType!
  node: Video
  updatedFields: [String!]
  previousValues: VideoPreviousValues
}

input VideoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VideoWhereInput
  AND: [VideoSubscriptionWhereInput!]
  OR: [VideoSubscriptionWhereInput!]
  NOT: [VideoSubscriptionWhereInput!]
}

input VideoUpdateDataInput {
  name: String
  url: String
  display: DisplayUpdateOneRequiredInput
  season: SeasonUpdateOneWithoutEpisodesInput
}

input VideoUpdateInput {
  name: String
  url: String
  display: DisplayUpdateOneRequiredInput
  season: SeasonUpdateOneWithoutEpisodesInput
}

input VideoUpdateManyDataInput {
  name: String
  url: String
}

input VideoUpdateManyMutationInput {
  name: String
  url: String
}

input VideoUpdateManyWithoutSeasonInput {
  create: [VideoCreateWithoutSeasonInput!]
  delete: [VideoWhereUniqueInput!]
  connect: [VideoWhereUniqueInput!]
  set: [VideoWhereUniqueInput!]
  disconnect: [VideoWhereUniqueInput!]
  update: [VideoUpdateWithWhereUniqueWithoutSeasonInput!]
  upsert: [VideoUpsertWithWhereUniqueWithoutSeasonInput!]
  deleteMany: [VideoScalarWhereInput!]
  updateMany: [VideoUpdateManyWithWhereNestedInput!]
}

input VideoUpdateManyWithWhereNestedInput {
  where: VideoScalarWhereInput!
  data: VideoUpdateManyDataInput!
}

input VideoUpdateOneRequiredInput {
  create: VideoCreateInput
  update: VideoUpdateDataInput
  upsert: VideoUpsertNestedInput
  connect: VideoWhereUniqueInput
}

input VideoUpdateWithoutSeasonDataInput {
  name: String
  url: String
  display: DisplayUpdateOneRequiredInput
}

input VideoUpdateWithWhereUniqueWithoutSeasonInput {
  where: VideoWhereUniqueInput!
  data: VideoUpdateWithoutSeasonDataInput!
}

input VideoUpsertNestedInput {
  update: VideoUpdateDataInput!
  create: VideoCreateInput!
}

input VideoUpsertWithWhereUniqueWithoutSeasonInput {
  where: VideoWhereUniqueInput!
  update: VideoUpdateWithoutSeasonDataInput!
  create: VideoCreateWithoutSeasonInput!
}

input VideoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  display: DisplayWhereInput
  season: SeasonWhereInput
  AND: [VideoWhereInput!]
  OR: [VideoWhereInput!]
  NOT: [VideoWhereInput!]
}

input VideoWhereUniqueInput {
  id: ID
}
`